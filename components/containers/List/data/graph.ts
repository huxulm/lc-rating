import ProblemCategory from "@components/ProblemCatetory";

export default{
    "title": "分享丨【算法题单】图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）",
    "summary": "",
    "src": "",
    "original_src": "https://leetcode.cn/circle/discuss/01LUak",
    "sort": 0,
    "isLeaf": false,
    "solution": "",
    "score": 0,
    "leafChild": [],
    "nonLeafChild": [
        {
            "title": "一、图的遍历",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [
                {
                    "title": "计算每个连通块的大小",
                    "summary": "找连通块、判断是否有环（如 207 题）等。部分题目**做法不止一种**。<br>模板（计算每个连通块的大小）：<br>```py [sol-Python3]<br>def solve(n: int, edges: List[List[int]]) -> List[int]:<br>g = [[] for _ in range(n)]<br>for x, y in edges:<br>g[x].append(y)<br>g[y].append(x)  # 无向图<br>vis = [False] * n<br>def dfs(x: int) -> int:<br>vis[x] = True  # 避免重复访问节点<br>size = 1<br>for y in g[x]:<br>if not vis[y]:<br>size += dfs(y)<br>return size<br>ans = []<br>for i, b in enumerate(vis):<br>if not b:  # i 没有访问过<br>size = dfs(i)<br>ans.append(size)<br>return ans<br>```<br>```java [sol-Java]<br>class Solution {<br>public List<Integer> solve(int n, int[][] edges) {<br>// 节点编号从 0 到 n-1<br>List<Integer>[] g = new ArrayList[n];<br>Arrays.setAll(g, _ -> new ArrayList<>());<br>for (int[] e : edges) {<br>int x = e[0];<br>int y = e[1];<br>g[x].add(y);<br>g[y].add(x); // 无向图<br>}<br>// 计算每个连通块的大小<br>List<Integer> ans = new ArrayList<>();<br>boolean[] vis = new boolean[n];<br>for (int i = 0; i < n; i++) {<br>if (!vis[i]) { // i 没有访问过<br>int size = dfs(i, vis, g);<br>ans.add(size);<br>}<br>}<br>return ans;<br>}<br>private int dfs(int x, boolean[] vis, List<Integer>[] g) {<br>vis[x] = true; // 避免重复访问节点<br>int size = 1;<br>for (int y : g[x]) {<br>if (!vis[y]) {<br>size += dfs(y, vis, g);<br>}<br>}<br>return size;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>vector<int> solve(int n, vector<vector<int>>& edges) {<br>// 节点编号从 0 到 n-1<br>vector<vector<int>> g(n);<br>for (auto& e : edges) {<br>int x = e[0], y = e[1];<br>g[x].push_back(y);<br>g[y].push_back(x); // 无向图<br>}<br>vector<int8_t> vis(n);<br>// lambda 递归<br>auto dfs = [&](this auto&& dfs, int x) -> int {<br>vis[x] = true; // 避免重复访问节点<br>int size = 1;<br>for (int y : g[x]) {<br>if (!vis[y]) {<br>size += dfs(y);<br>}<br>}<br>return size;<br>};<br>// 计算每个连通块的大小<br>vector<int> ans;<br>for (int i = 0; i < n; i++) {<br>if (!vis[i]) { // i 没有访问过<br>int size = dfs(i);<br>ans.push_back(size);<br>}<br>}<br>return ans;<br>}<br>```<br>```go [sol-Go]<br>func solve(n int, edges [][]int) (ans []int) {<br>// 节点编号从 0 到 n-1<br>g := make([][]int, n)<br>for _, e := range edges {<br>x, y := e[0], e[1]<br>g[x] = append(g[x], y)<br>g[y] = append(g[y], x) // 无向图<br>}<br>vis := make([]bool, n)<br>var dfs func(int) int<br>dfs = func(x int) int {<br>vis[x] = true // 避免重复访问节点<br>size := 1<br>for _, y := range g[x] {<br>if !vis[y] {<br>size += dfs(y)<br>}<br>}<br>return size<br>}<br>// 计算每个连通块的大小<br>for i, b := range vis {<br>if !b { // i 没有访问过<br>size := dfs(i)<br>ans = append(ans, size)<br>}<br>}<br>return<br>}<br>```<br>**思维扩展**：<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "547. 省份数量",
                            "summary": "",
                            "src": "/number-of-provinces/",
                            "original_src": "https://leetcode.cn/problems/number-of-provinces/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1971. 寻找图中是否存在路径",
                            "summary": "",
                            "src": "/find-if-path-exists-in-graph/",
                            "original_src": "https://leetcode.cn/problems/find-if-path-exists-in-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "797. 所有可能的路径",
                            "summary": "",
                            "src": "/all-paths-from-source-to-target/",
                            "original_src": "https://leetcode.cn/problems/all-paths-from-source-to-target/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1382.5129151601,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1306. 跳跃游戏 III",
                            "summary": "",
                            "src": "/jump-game-iii/",
                            "original_src": "https://leetcode.cn/problems/jump-game-iii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1396.5448074496,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "841. 钥匙和房间",
                            "summary": "",
                            "src": "/keys-and-rooms/",
                            "original_src": "https://leetcode.cn/problems/keys-and-rooms/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1412.2790156634,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2316. 统计无向图中无法互相到达点对数",
                            "summary": "",
                            "src": "/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
                            "original_src": "https://leetcode.cn/problems/count-unreachable-pairs-of-nodes-in-an-undirected-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1604.0695445163,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1319. 连通网络的操作次数",
                            "summary": "",
                            "src": "/number-of-operations-to-make-network-connected/",
                            "original_src": "https://leetcode.cn/problems/number-of-operations-to-make-network-connected/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1633.1372577433,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2492. 两个城市间路径的最小分数",
                            "summary": "",
                            "src": "/minimum-score-of-a-path-between-two-cities/",
                            "original_src": "https://leetcode.cn/problems/minimum-score-of-a-path-between-two-cities/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1679.5737760149,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3310. 移除可疑的方法",
                            "summary": "",
                            "src": "/remove-methods-from-project/",
                            "original_src": "https://leetcode.cn/problems/remove-methods-from-project/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1710.5210499321,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2685. 统计完全连通分量的数量",
                            "summary": "",
                            "src": "/count-the-number-of-complete-components/",
                            "original_src": "https://leetcode.cn/problems/count-the-number-of-complete-components/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1769.4344566771,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2192. 有向无环图中一个节点的所有祖先",
                            "summary": "",
                            "src": "/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
                            "original_src": "https://leetcode.cn/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1787.8550568757,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3387. 两天自由外汇交易后的最大货币数",
                            "summary": "",
                            "src": "/maximize-amount-after-two-days-of-conversions/",
                            "original_src": "https://leetcode.cn/problems/maximize-amount-after-two-days-of-conversions/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1787.5923894417,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "924. 尽量减少恶意软件的传播",
                            "summary": "",
                            "src": "/minimize-malware-spread/",
                            "original_src": "https://leetcode.cn/problems/minimize-malware-spread/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1868.9146755896,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2101. 引爆最多的炸弹",
                            "summary": "",
                            "src": "/detonate-the-maximum-bombs/",
                            "original_src": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1880.0511044074,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "721. 账户合并",
                            "summary": "",
                            "src": "/accounts-merge/",
                            "original_src": "https://leetcode.cn/problems/accounts-merge/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "207. 课程表",
                            "summary": "",
                            "src": "/course-schedule/",
                            "original_src": "https://leetcode.cn/problems/course-schedule/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "802. 找到最终的安全状态",
                            "summary": "",
                            "src": "/find-eventual-safe-states/",
                            "original_src": "https://leetcode.cn/problems/find-eventual-safe-states/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1962.3314335449,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3695. 交换元素后的最大交替和",
                            "summary": "",
                            "src": "/maximize-alternating-sum-using-swaps/",
                            "original_src": "https://leetcode.cn/problems/maximize-alternating-sum-using-swaps/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1984.157304677,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "928. 尽量减少恶意软件的传播 II",
                            "summary": "",
                            "src": "/minimize-malware-spread-ii/",
                            "original_src": "https://leetcode.cn/problems/minimize-malware-spread-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1985.2504512337,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2092. 找出知晓秘密的所有专家",
                            "summary": "",
                            "src": "/find-all-people-with-secret/",
                            "original_src": "https://leetcode.cn/problems/find-all-people-with-secret/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2003.5794613668,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3108. 带权图里旅途的最小代价",
                            "summary": "",
                            "src": "/minimum-cost-walk-in-weighted-graph/",
                            "original_src": "https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2108.5054318055,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 07. 传递信息",
                            "summary": "",
                            "src": "/chuan-di-xin-xi/",
                            "original_src": "https://leetcode.cn/problems/chuan-di-xin-xi/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "261. 以图判树",
                            "summary": "",
                            "src": "/graph-valid-tree/",
                            "original_src": "https://leetcode.cn/problems/graph-valid-tree/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "323. 无向图中连通分量的数目",
                            "summary": "",
                            "src": "/number-of-connected-components-in-an-undirected-graph/",
                            "original_src": "https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "1298. 你能从盒子里获得的最大糖果数",
                            "summary": "",
                            "src": "/maximum-candies-you-can-get-from-boxes/",
                            "original_src": "https://leetcode.cn/problems/maximum-candies-you-can-get-from-boxes/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1824.829446341,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "§1.2 广度优先搜索（BFS）",
                    "summary": "求最短路等。要求边权都是 $1$（或者说都是同一个正数）。<br>模板（单源最短路）：<br>```py [sol-Python3]<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "计算从 start 到各个节点的最短路长度",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果节点不可达，则最短路长度为 -1",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "节点编号从 0 到 n-1，边权均为 1",
            "summary": "def bfs(n: int, edges: List[List[int]], start: int) -> List[int]:<br>g = [[] for _ in range(n)]<br>for x, y in edges:<br>g[x].append(y)<br>g[y].append(x)  # 无向图<br>dis = [-1] * n  # -1 表示尚未访问到<br>dis[start] = 0<br>q = deque([start])<br>while q:<br>x = q.popleft()<br>for y in g[x]:<br>if dis[y] < 0:<br>dis[y] = dis[x] + 1<br>q.append(y)<br>return dis<br>```<br>```java [sol-Java]<br>class Solution {<br>// 计算从 start 到各个节点的最短路长度<br>// 如果节点不可达，则最短路长度为 -1<br>// 节点编号从 0 到 n-1，边权均为 1<br>public int[] bfs(int n, int[][] edges, int start) {<br>List<Integer>[] g = new ArrayList[n];<br>Arrays.setAll(g, _ -> new ArrayList<>());<br>for (int[] e : edges) {<br>int x = e[0], y = e[1];<br>g[x].add(y);<br>g[y].add(x); // 无向图<br>}<br>int[] dis = new int[n];<br>Arrays.fill(dis, -1); // -1 表示尚未访问到<br>Queue<Integer> q = new ArrayDeque<>();<br>dis[start] = 0;<br>q.offer(start);<br>while (!q.isEmpty()) {<br>int x = q.poll();<br>for (int y : g[x]) {<br>if (dis[y] < 0) {<br>dis[y] = dis[x] + 1;<br>q.offer(y);<br>}<br>}<br>}<br>return dis;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 计算从 start 到各个节点的最短路长度<br>// 如果节点不可达，则最短路长度为 -1<br>// 节点编号从 0 到 n-1，边权均为 1<br>vector<int> bfs(int n, vector<vector<int>>& edges, int start) {<br>vector<vector<int>> g(n);<br>for (auto& e : edges) {<br>int x = e[0], y = e[1];<br>g[x].push_back(y);<br>g[y].push_back(x); // 无向图<br>}<br>vector<int> dis(n, -1); // -1 表示尚未访问到<br>queue<int> q;<br>dis[start] = 0;<br>q.push(start);<br>while (!q.empty()) {<br>int x = q.front();<br>q.pop();<br>for (int y : g[x]) {<br>if (dis[y] < 0) {<br>dis[y] = dis[x] + 1;<br>q.push(y);<br>}<br>}<br>}<br>return dis;<br>}<br>```<br>```go [sol-Go]<br>// 计算从 start 到各个节点的最短路长度<br>// 如果节点不可达，则最短路长度为 -1<br>// 节点编号从 0 到 n-1，边权均为 1<br>func bfs(n int, edges [][]int, start int) []int {<br>g := make([][]int, n)<br>for _, e := range edges {<br>x, y := e[0], e[1]<br>g[x] = append(g[x], y)<br>g[y] = append(g[y], x) // 无向图<br>}<br>dis := make([]int, n)<br>for i := range dis {<br>dis[i] = -1 // -1 表示尚未访问到<br>}<br>dis[start] = 0<br>q := []int{start}<br>for len(q) > 0 {<br>x := q[0]<br>q = q[1:]<br>for _, y := range g[x] {<br>if dis[y] < 0 {<br>dis[y] = dis[x] + 1<br>q = append(q, y)<br>}<br>}<br>}<br>return dis<br>}<br>```<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "3243. 新增道路查询后的最短距离 I",
                    "summary": "",
                    "src": "/shortest-distance-after-road-addition-queries-i/",
                    "original_src": "https://leetcode.cn/problems/shortest-distance-after-road-addition-queries-i/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1567.8396535313,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1311. 获取你好友已观看的视频",
                    "summary": "",
                    "src": "/get-watched-videos-by-your-friends/",
                    "original_src": "https://leetcode.cn/problems/get-watched-videos-by-your-friends/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1652.5809810428,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3015. 按距离统计房屋对数目 I",
                    "summary": "",
                    "src": "/count-the-number-of-houses-at-a-certain-distance-i/",
                    "original_src": "https://leetcode.cn/problems/count-the-number-of-houses-at-a-certain-distance-i/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1657.5344546445,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1129. 颜色交替的最短路径",
                    "summary": "",
                    "src": "/shortest-path-with-alternating-colors/",
                    "original_src": "https://leetcode.cn/problems/shortest-path-with-alternating-colors/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1779.7534349429,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2039. 网络空闲的时刻",
                    "summary": "",
                    "src": "/the-time-when-the-network-becomes-idle/",
                    "original_src": "https://leetcode.cn/problems/the-time-when-the-network-becomes-idle/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1865.3441063734,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2608. 图中的最短环",
                    "summary": "",
                    "src": "/shortest-cycle-in-a-graph/",
                    "original_src": "https://leetcode.cn/problems/shortest-cycle-in-a-graph/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1904.2279434479,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "815. 公交路线",
                    "summary": "",
                    "src": "/bus-routes/",
                    "original_src": "https://leetcode.cn/problems/bus-routes/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1964.3793590858,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "§1.3 图论建模 + BFS 最短路",
                    "summary": "把状态抽象成图上的点，用 BFS 遍历这张图，计算从初始状态到目标状态的最短路长度。<br>可以锻炼状态设计能力。<br>**专题：跳跃游戏**<br>注：关于**网格图**的 DFS 和 BFS，请看 <a href=\"/lc-rating/list/grid\">网格图题单</a>。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "433. 最小基因变化",
                            "summary": "",
                            "src": "/minimum-genetic-mutation/",
                            "original_src": "https://leetcode.cn/problems/minimum-genetic-mutation/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1284. 转化为全零矩阵的最少反转次数",
                            "summary": "",
                            "src": "/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/",
                            "original_src": "https://leetcode.cn/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1810.7690062079,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "773. 滑动谜题",
                            "summary": "",
                            "src": "/sliding-puzzle/",
                            "original_src": "https://leetcode.cn/problems/sliding-puzzle/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1815.1286459024,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "752. 打开转盘锁",
                            "summary": "",
                            "src": "/open-the-lock/",
                            "original_src": "https://leetcode.cn/problems/open-the-lock/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1877.5624603804,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3690. 拆分合并数组",
                            "summary": "",
                            "src": "/split-and-merge-array-transformation/",
                            "original_src": "https://leetcode.cn/problems/split-and-merge-array-transformation/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1982.4524895112,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "301. 删除无效的括号",
                            "summary": "",
                            "src": "/remove-invalid-parentheses/",
                            "original_src": "https://leetcode.cn/problems/remove-invalid-parentheses/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "514. 自由之路",
                            "summary": "",
                            "src": "/freedom-trail/",
                            "original_src": "https://leetcode.cn/problems/freedom-trail/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "847. 访问所有节点的最短路径",
                            "summary": "",
                            "src": "/shortest-path-visiting-all-nodes/",
                            "original_src": "https://leetcode.cn/problems/shortest-path-visiting-all-nodes/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2200.6623666057,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "854. 相似度为 K 的字符串",
                            "summary": "",
                            "src": "/k-similar-strings/",
                            "original_src": "https://leetcode.cn/problems/k-similar-strings/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2377.3895801187,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "127. 单词接龙",
                            "summary": "",
                            "src": "/word-ladder/",
                            "original_src": "https://leetcode.cn/problems/word-ladder/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "488. 祖玛游戏",
                            "summary": "",
                            "src": "/zuma-game/",
                            "original_src": "https://leetcode.cn/problems/zuma-game/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1197. 进击的骑士",
                            "summary": "",
                            "src": "/minimum-knight-moves/",
                            "original_src": "https://leetcode.cn/problems/minimum-knight-moves/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1722.3088173214,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "3141. 最大汉明距离",
                            "summary": "",
                            "src": "/maximum-hamming-distances/",
                            "original_src": "https://leetcode.cn/problems/maximum-hamming-distances/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "2998. 使 X 和 Y 相等的最少操作次数",
                            "summary": "",
                            "src": "/minimum-number-of-operations-to-make-x-and-y-equal/",
                            "original_src": "https://leetcode.cn/problems/minimum-number-of-operations-to-make-x-and-y-equal/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1794.6129370985,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1345. 跳跃游戏 IV",
                            "summary": "",
                            "src": "/jump-game-iv/",
                            "original_src": "https://leetcode.cn/problems/jump-game-iv/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1809.8192888474,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2059. 转化数字的最小运算数",
                            "summary": "",
                            "src": "/minimum-operations-to-convert-number/",
                            "original_src": "https://leetcode.cn/problems/minimum-operations-to-convert-number/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1849.8122180044,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1654. 到家的最少跳跃次数",
                            "summary": "",
                            "src": "/minimum-jumps-to-reach-home/",
                            "original_src": "https://leetcode.cn/problems/minimum-jumps-to-reach-home/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2124.0317207867,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3629. 通过质数传送到达终点的最少跳跃次数",
                            "summary": "",
                            "src": "/minimum-jumps-to-reach-end-via-prime-teleportation/",
                            "original_src": "https://leetcode.cn/problems/minimum-jumps-to-reach-end-via-prime-teleportation/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2139.3079901181,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 09. 最小跳跃次数",
                            "summary": "",
                            "src": "/zui-xiao-tiao-yue-ci-shu/",
                            "original_src": "https://leetcode.cn/problems/zui-xiao-tiao-yue-ci-shu/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "二、拓扑排序",
                    "summary": "<img src=\"https://pic.leetcode.cn/1738131168-tWFNGZ-006-toposort.png\" alt=\"图论题单 图论算法 图论题目 LeetCode 力扣图论 灵茶山艾府\" style=\"width: 100%;\"><br>把拓扑排序想象成一个黑盒，给它一堆杂乱的先修课约束，它会给你一个井井有条的课程学习安排。<br>这一种在图上的「排序」，可以把杂乱的点排成一排。前提条件是图中无环，从而保证每条边都是从排在前面的点，指向排在后面的点。即对于任意有向边 $x\\to y$，$x$ 一定在 $y$ 之前。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [
                        {
                            "title": "§2.1 拓扑排序",
                            "summary": "模板：<br>```py [sol-Python3]<br>",
                            "src": "",
                            "original_src": "",
                            "sort": 0,
                            "isLeaf": false,
                            "solution": "",
                            "score": 0,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "返回有向无环图（DAG）的其中一个拓扑序",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果图中有环，返回空列表",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "节点编号从 0 到 n-1",
            "summary": "def topologicalSort(n: int, edges: List[List[int]]) -> List[int]:<br>g = [[] for _ in range(n)]<br>in_deg = [0] * n<br>for x, y in edges:<br>g[x].append(y)<br>in_deg[y] += 1  # 统计 y 的先修课数量<br>topo_order = []<br>q = deque(i for i, d in enumerate(in_deg) if d == 0)  # 没有先修课，可以直接上<br>while q:<br>x = q.popleft()<br>topo_order.append(x)<br>for y in g[x]:<br>in_deg[y] -= 1  # 修完 x 后，y 的先修课数量减一<br>if in_deg[y] == 0:  # y 的先修课全部上完<br>q.append(y)  # 加入学习队列<br>if len(topo_order) < n:  # 图中有环<br>return []<br>return topo_order<br>```<br>```java [sol-Java]<br>class Solution {<br>// 返回有向无环图（DAG）的其中一个拓扑序<br>// 如果图中有环，返回空列表<br>// 节点编号从 0 到 n-1<br>public List<Integer> topologicalSort(int n, int[][] edges) {<br>List<Integer>[] g = new ArrayList[n];<br>Arrays.setAll(g, _ -> new ArrayList<>());<br>int[] inDeg = new int[n];<br>for (int[] e : edges) {<br>int x = e[0];<br>int y = e[1];<br>g[x].add(y);<br>inDeg[y]++; // 统计 y 的先修课数量<br>}<br>Queue<Integer> q = new ArrayDeque<>();<br>for (int i = 0; i < n; i++) {<br>if (inDeg[i] == 0) { // 没有先修课，可以直接上<br>q.offer(i); // 加入学习队列<br>}<br>}<br>List<Integer> topoOrder = new ArrayList<>();<br>while (!q.isEmpty()) {<br>int x = q.poll();<br>topoOrder.add(x);<br>for (int y : g[x]) {<br>inDeg[y]--; // 修完 x 后，y 的先修课数量减一<br>if (inDeg[y] == 0) { // y 的先修课全部上完<br>q.offer(y); // 加入学习队列<br>}<br>}<br>}<br>if (topoOrder.size() < n) { // 图中有环<br>return List.of();<br>}<br>return topoOrder;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 返回有向无环图（DAG）的其中一个拓扑序<br>// 如果图中有环，返回空列表<br>// 节点编号从 0 到 n-1<br>vector<int> topologicalSort(int n, vector<vector<int>>& edges) {<br>vector<vector<int>> g(n);<br>vector<int> in_deg(n);<br>for (auto& e : edges) {<br>int x = e[0], y = e[1];<br>g[x].push_back(y);<br>in_deg[y]++; // 统计 y 的先修课数量<br>}<br>queue<int> q;<br>for (int i = 0; i < n; i++) {<br>if (in_deg[i] == 0) { // 没有先修课，可以直接上<br>q.push(i); // 加入学习队列<br>}<br>}<br>vector<int> topo_order;<br>while (!q.empty()) {<br>int x = q.front();<br>q.pop();<br>topo_order.push_back(x);<br>for (int y : g[x]) {<br>in_deg[y]--; // 修完 x 后，y 的先修课数量减一<br>if (in_deg[y] == 0) { // y 的先修课全部上完<br>q.push(y); // 加入学习队列<br>}<br>}<br>}<br>if (topo_order.size() < n) { // 图中有环<br>return {};<br>}<br>return topo_order;<br>}<br>```<br>```go [sol-Go]<br>// 返回有向无环图（DAG）的其中一个拓扑序<br>// 如果图中有环，返回 nil<br>// 节点编号从 0 到 n-1<br>func topologicalSort(n int, edges [][]int) []int {<br>g := make([][]int, n)<br>inDeg := make([]int, n)<br>for _, e := range edges {<br>x, y := e[0], e[1]<br>g[x] = append(g[x], y)<br>inDeg[y]++ // 统计 y 的先修课数量<br>}<br>q := make([]int, 0, n)<br>topoOrder := q<br>for i, d := range inDeg {<br>if d == 0 { // 没有先修课，可以直接上<br>q = append(q, i) // 加入学习队列<br>}<br>}<br>for len(q) > 0 {<br>x := q[0]<br>q = q[1:]<br>for _, y := range g[x] {<br>inDeg[y]-- // 修完 x 后， y 的先修课数量减一<br>if inDeg[y] == 0 { // y 的先修课全部上完<br>q = append(q, y) // 加入学习队列<br>}<br>}<br>}<br>if cap(q) > 0 { // 图中有环<br>return nil<br>}<br>return topoOrder[:n]<br>}<br>```<br>学习拓扑排序前，请先完成 <a href=\"https://leetcode.cn/problems/minimum-number-of-vertices-to-reach-all-nodes/\">1557. 可以到达所有点的最少点数目</a>，有助于理解拓扑排序。<br>**思维扩展**：<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "210. 课程表 II",
                    "summary": "",
                    "src": "/course-schedule-ii/",
                    "original_src": "https://leetcode.cn/problems/course-schedule-ii/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2115. 从给定原材料中找到所有可以做出的菜",
                    "summary": "",
                    "src": "/find-all-possible-recipes-from-given-supplies/",
                    "original_src": "https://leetcode.cn/problems/find-all-possible-recipes-from-given-supplies/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1678.5871762113,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2392. 给定条件下构造矩阵",
                    "summary": "",
                    "src": "/build-a-matrix-with-conditions/",
                    "original_src": "https://leetcode.cn/problems/build-a-matrix-with-conditions/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1960.5517123728,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "802. 找到最终的安全状态",
                    "summary": "",
                    "src": "/find-eventual-safe-states/",
                    "original_src": "https://leetcode.cn/problems/find-eventual-safe-states/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1962.3314335449,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1591. 奇怪的打印机 II",
                    "summary": "",
                    "src": "/strange-printer-ii/",
                    "original_src": "https://leetcode.cn/problems/strange-printer-ii/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2290.9040038639,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1203. 项目管理",
                    "summary": "",
                    "src": "/sort-items-by-groups-respecting-dependencies/",
                    "original_src": "https://leetcode.cn/problems/sort-items-by-groups-respecting-dependencies/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2418.5742747632,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2603. 收集树中金币",
                    "summary": "",
                    "src": "/collect-coins-in-a-tree/",
                    "original_src": "https://leetcode.cn/problems/collect-coins-in-a-tree/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2711.8717381409,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "LCR 114. 火星词典",
                    "summary": "",
                    "src": "/Jf1JuT/",
                    "original_src": "https://leetcode.cn/problems/Jf1JuT/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "444. 序列重建",
                    "summary": "",
                    "src": "/sequence-reconstruction/",
                    "original_src": "https://leetcode.cn/problems/sequence-reconstruction/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "3481. 应用替换",
                    "summary": "",
                    "src": "/apply-substitutions/",
                    "original_src": "https://leetcode.cn/problems/apply-substitutions/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "269. 火星词典",
                    "summary": "",
                    "src": "/alien-dictionary/",
                    "original_src": "https://leetcode.cn/problems/alien-dictionary/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "1059. 从始点到终点的所有路径",
                    "summary": "",
                    "src": "/all-paths-from-source-lead-to-destination/",
                    "original_src": "https://leetcode.cn/problems/all-paths-from-source-lead-to-destination/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "310. 最小高度树",
                    "summary": "",
                    "src": "/minimum-height-trees/",
                    "original_src": "https://leetcode.cn/problems/minimum-height-trees/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1361. 验证二叉树",
                    "summary": "",
                    "src": "/validate-binary-tree-nodes/",
                    "original_src": "https://leetcode.cn/problems/validate-binary-tree-nodes/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1464.6895034875,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "§2.2 在拓扑序上 DP",
                    "summary": "一般是刷表法。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "851. 喧闹和富有",
                            "summary": "",
                            "src": "/loud-and-rich/",
                            "original_src": "https://leetcode.cn/problems/loud-and-rich/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1783.2337340478,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2050. 并行课程 III",
                            "summary": "",
                            "src": "/parallel-courses-iii/",
                            "original_src": "https://leetcode.cn/problems/parallel-courses-iii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2084.1404698713,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3620. 恢复网络路径",
                            "summary": "",
                            "src": "/network-recovery-pathways/",
                            "original_src": "https://leetcode.cn/problems/network-recovery-pathways/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1998.0432529701,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1857. 有向图中最大颜色值",
                            "summary": "",
                            "src": "/largest-color-value-in-a-directed-graph/",
                            "original_src": "https://leetcode.cn/problems/largest-color-value-in-a-directed-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2312.9919953644,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1136. 并行课程",
                            "summary": "",
                            "src": "/parallel-courses/",
                            "original_src": "https://leetcode.cn/problems/parallel-courses/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1710.0787625377,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "§2.3 基环树",
                    "summary": "<a href=\"https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/solution/nei-xiang-ji-huan-shu-tuo-bu-pai-xu-fen-c1i1b/\">基环树介绍</a><br>**思维扩展**：<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "2359. 找到离给定两个节点最近的节点",
                            "summary": "",
                            "src": "/find-closest-node-to-given-two-nodes/",
                            "original_src": "https://leetcode.cn/problems/find-closest-node-to-given-two-nodes/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1714.992763701,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2360. 图中的最长环",
                            "summary": "",
                            "src": "/longest-cycle-in-a-graph/",
                            "original_src": "https://leetcode.cn/problems/longest-cycle-in-a-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1897.1863301576,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "684. 冗余连接",
                            "summary": "",
                            "src": "/redundant-connection/",
                            "original_src": "https://leetcode.cn/problems/redundant-connection/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "685. 冗余连接 II",
                            "summary": "",
                            "src": "/redundant-connection-ii/",
                            "original_src": "https://leetcode.cn/problems/redundant-connection-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2876. 有向图访问计数",
                            "summary": "",
                            "src": "/count-visited-nodes-in-a-directed-graph/",
                            "original_src": "https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2209.8785430371,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2127. 参加会议的最多员工数",
                            "summary": "",
                            "src": "/maximum-employees-to-be-invited-to-a-meeting/",
                            "original_src": "https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2449.1323757838,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2836. 在传球游戏中最大化函数值",
                            "summary": "",
                            "src": "/maximize-value-of-function-in-a-ball-passing-game",
                            "original_src": "https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-passing-game",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2768.8154223451,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 21. 追逐游戏",
                            "summary": "",
                            "src": "/Za25hA/",
                            "original_src": "https://leetcode.cn/problems/Za25hA/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2204. 无向图中到环的距离",
                            "summary": "",
                            "src": "/distance-to-a-cycle-in-undirected-graph/",
                            "original_src": "https://leetcode.cn/problems/distance-to-a-cycle-in-undirected-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "287. 寻找重复数",
                            "summary": "",
                            "src": "/find-the-duplicate-number/",
                            "original_src": "https://leetcode.cn/problems/find-the-duplicate-number/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "三、最短路",
                    "summary": "",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [
                        {
                            "title": "§3.1 单源最短路：Dijkstra 算法",
                            "summary": "<a href=\"https://leetcode.cn/problems/network-delay-time/solution/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/\">Dijkstra 算法介绍</a><br>模板：<br>```py [sol-Python3]<br>",
                            "src": "",
                            "original_src": "",
                            "sort": 0,
                            "isLeaf": false,
                            "solution": "",
                            "score": 0,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = math.inf",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "要求：没有负数边权",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "相同节点可能有多个不同的 new_dis_y，除了最小的 new_dis_y，其余值都会触发上面的 continue",
            "summary": "def shortestPathDijkstra(n: int, edges: List[List[int]], start: int) -> List[int]:<br>g = [[] for _ in range(n)]  # 邻接表<br>for x, y, wt in edges:<br>g[x].append((y, wt))<br>dis = [inf] * n<br>dis[start] = 0  # 起点到自己的距离是 0<br>h = [(0, start)]  # 堆中保存 (起点到节点 x 的最短路长度，节点 x)<br>while h:<br>dis_x, x = heappop(h)<br>if dis_x > dis[x]:  # x 之前出堆过<br>continue<br>for y, wt in g[x]:<br>new_dis_y = dis_x + wt<br>if new_dis_y < dis[y]:<br>dis[y] = new_dis_y  # 更新 x 的邻居的最短路<br>heappush(h, (new_dis_y, y))<br>return dis<br>```<br>```java [sol-Java]<br>class Solution {<br>// 返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = Integer.MAX_VALUE<br>// 要求：没有负数边权<br>// 时间复杂度 O(n + mlogm)，注意堆中有 O(m) 个元素<br>private int[] shortestPathDijkstra(int n, int[][] edges, int start) {<br>// 注：如果节点编号从 1 开始（而不是从 0 开始），可以把 n 加一<br>List<int[]>[] g = new ArrayList[n]; // 邻接表<br>Arrays.setAll(g, _ -> new ArrayList<>());<br>for (int[] e : edges) {<br>int x = e[0];<br>int y = e[1];<br>int wt = e[2];<br>g[x].add(new int[]{y, wt});<br>// g[y].add(new int[]{x, wt}); // 无向图加上这行<br>}<br>int[] dis = new int[n]; // **如果数据范围大，改成 long[]**<br>Arrays.fill(dis, Integer.MAX_VALUE);<br>// 堆中保存 (起点到节点 x 的最短路长度，节点 x)<br>PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));<br>dis[start] = 0; // 起点到自己的距离是 0<br>pq.offer(new int[]{0, start});<br>while (!pq.isEmpty()) {<br>int[] p = pq.poll();<br>int disX = p[0];<br>int x = p[1];<br>if (disX > dis[x]) { // x 之前出堆过<br>continue;<br>}<br>for (int[] e : g[x]) {<br>int y = e[0];<br>int wt = e[1];<br>int newDisY = disX + wt;<br>if (newDisY < dis[y]) {<br>dis[y] = newDisY; // 更新 x 的邻居的最短路<br>// 懒更新堆：只插入数据，不更新堆中数据<br>// 相同节点可能有多个不同的 newDisY，除了最小的 newDisY，其余值都会触发上面的 continue<br>pq.offer(new int[]{newDisY, y});<br>}<br>}<br>}<br>return dis;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = LLONG_MAX<br>// 要求：没有负数边权<br>// 时间复杂度 O(n + mlogm)，注意堆中有 O(m) 个元素<br>vector<long long> shortestPathDijkstra(int n, vector<vector<int>>& edges, int start) {<br>// 注：如果节点编号从 1 开始（而不是从 0 开始），可以把 n 加一<br>vector<vector<pair<int, int>>> g(n); // 邻接表<br>for (auto& e : edges) {<br>int x = e[0], y = e[1], wt = e[2];<br>g[x].emplace_back(y, wt);<br>// g[y].emplace_back(x, wt); // 无向图加上这行<br>}<br>vector<long long> dis(n, LLONG_MAX);<br>// 堆中保存 (起点到节点 x 的最短路长度，节点 x)<br>priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;<br>dis[start] = 0; // 起点到自己的距离是 0<br>pq.emplace(0, start);<br>while (!pq.empty()) {<br>auto [dis_x, x] = pq.top();<br>pq.pop();<br>if (dis_x > dis[x]) { // x 之前出堆过<br>continue;<br>}<br>for (auto& [y, wt] : g[x]) {<br>auto new_dis_y = dis_x + wt;<br>if (new_dis_y < dis[y]) {<br>dis[y] = new_dis_y; // 更新 x 的邻居的最短路<br>// 懒更新堆：只插入数据，不更新堆中数据<br>// 相同节点可能有多个不同的 new_dis_y，除了最小的 new_dis_y，其余值都会触发上面的 continue<br>pq.emplace(new_dis_y, y);<br>}<br>}<br>}<br>return dis;<br>}<br>```<br>```go [sol-Go]<br>// 返回从起点 start 到每个点的最短路长度 dis，如果节点 x 不可达，则 dis[x] = math.MaxInt<br>// 要求：没有负数边权<br>// 时间复杂度 O(n + mlogm)，注意堆中有 O(m) 个元素<br>func shortestPathDijkstra(n int, edges [][]int, start int) []int {<br>// 注：如果节点编号从 1 开始（而不是从 0 开始），可以把 n 加一<br>type edge struct{ to, wt int }<br>g := make([][]edge, n) // 邻接表<br>for _, e := range edges {<br>x, y, wt := e[0], e[1], e[2]<br>g[x] = append(g[x], edge{y, wt})<br>// g[y] = append(g[y], edge{x, wt}) // 无向图加上这行<br>}<br>dis := make([]int, n)<br>for i := range dis {<br>dis[i] = math.MaxInt<br>}<br>dis[start] = 0 // 起点到自己的距离是 0<br>// 堆中保存 (起点到节点 x 的最短路长度，节点 x)<br>h := &hp{{0, start}}<br>for h.Len() > 0 {<br>p := heap.Pop(h).(pair)<br>disX, x := p.dis, p.x<br>if disX > dis[x] { // x 之前出堆过<br>continue<br>}<br>for _, e := range g[x] {<br>y := e.to<br>newDisY := disX + e.wt<br>if newDisY < dis[y] {<br>dis[y] = newDisY // 更新 x 的邻居的最短路<br>// 懒更新堆：只插入数据，不更新堆中数据<br>// 相同节点可能有多个不同的 newDisY，除了最小的 newDisY，其余值都会触发上面的 continue<br>heap.Push(h, pair{newDisY, y})<br>}<br>}<br>}<br>return dis<br>}<br>type pair struct{ dis, x int }<br>type hp []pair<br>func (h hp) Len() int           { return len(h) }<br>func (h hp) Less(i, j int) bool { return h[i].dis < h[j].dis }<br>func (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }<br>func (h *hp) Push(v any)        { *h = append(*h, v.(pair)) }<br>func (h *hp) Pop() (v any)      { a := *h; *h, v = a[:len(a)-1], a[len(a)-1]; return }<br>```<br>**分层图最短路**：<br>**SPFA 与差分约束**：<br>> 力扣上的 SPFA 题很少。<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "743. 网络延迟时间",
                    "summary": "",
                    "src": "/network-delay-time/",
                    "original_src": "https://leetcode.cn/problems/network-delay-time/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3341. 到达最后一个房间的最少时间 I",
                    "summary": "",
                    "src": "/find-minimum-time-to-reach-last-room-i/",
                    "original_src": "https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-i/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1721.4793821913,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3112. 访问消失节点的最少时间",
                    "summary": "",
                    "src": "/minimum-time-to-visit-disappearing-nodes/",
                    "original_src": "https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1756.963553993,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2642. 设计可以求最短路径的图类",
                    "summary": "",
                    "src": "/design-graph-with-shortest-path-calculator/",
                    "original_src": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1810.6470004623,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3604. 有向图中到达终点的最少时间",
                    "summary": "",
                    "src": "/minimum-time-to-reach-destination-in-directed-graph/",
                    "original_src": "https://leetcode.cn/problems/minimum-time-to-reach-destination-in-directed-graph/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1844.6347254612,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1514. 概率最大的路径",
                    "summary": "",
                    "src": "/path-with-maximum-probability/",
                    "original_src": "https://leetcode.cn/problems/path-with-maximum-probability/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1846.4077077642,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3650. 边反转的最小路径总成本",
                    "summary": "",
                    "src": "/minimum-cost-path-with-edge-reversals/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-path-with-edge-reversals/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1853.6535583817,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3342. 到达最后一个房间的最少时间 II",
                    "summary": "",
                    "src": "/find-minimum-time-to-reach-last-room-ii/",
                    "original_src": "https://leetcode.cn/problems/find-minimum-time-to-reach-last-room-ii/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1861.7421056879,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1631. 最小体力消耗路径",
                    "summary": "",
                    "src": "/path-with-minimum-effort/",
                    "original_src": "https://leetcode.cn/problems/path-with-minimum-effort/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1947.5013967785,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1786. 从第一个节点出发到最后一个节点的受限路径数",
                    "summary": "",
                    "src": "/number-of-restricted-paths-from-first-to-last-node/",
                    "original_src": "https://leetcode.cn/problems/number-of-restricted-paths-from-first-to-last-node/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2078.5417326415,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3123. 最短路径中的边",
                    "summary": "",
                    "src": "/find-edges-in-shortest-paths/",
                    "original_src": "https://leetcode.cn/problems/find-edges-in-shortest-paths/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2093.0316157073,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1976. 到达目的地的方案数",
                    "summary": "",
                    "src": "/number-of-ways-to-arrive-at-destination/",
                    "original_src": "https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2094.592426537,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "778. 水位上升的泳池中游泳",
                    "summary": "",
                    "src": "/swim-in-rising-water/",
                    "original_src": "https://leetcode.cn/problems/swim-in-rising-water/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2096.6201393558,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2662. 前往目标的最小代价",
                    "summary": "",
                    "src": "/minimum-cost-of-a-path-with-special-roads/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-of-a-path-with-special-roads/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2153.8943791656,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3377. 使两个整数相等的数位操作",
                    "summary": "",
                    "src": "/digit-operations-to-make-two-integers-equal/",
                    "original_src": "https://leetcode.cn/problems/digit-operations-to-make-two-integers-equal/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2186.3802199168,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2045. 到达目的地的第二短时间",
                    "summary": "",
                    "src": "/second-minimum-time-to-reach-destination/",
                    "original_src": "https://leetcode.cn/problems/second-minimum-time-to-reach-destination/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2201.6219336792,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3419. 图的最大边权的最小值",
                    "summary": "",
                    "src": "/minimize-the-maximum-edge-weight-of-graph/",
                    "original_src": "https://leetcode.cn/problems/minimize-the-maximum-edge-weight-of-graph/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2243.2051062979,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "882. 细分图中的可到达节点",
                    "summary": "",
                    "src": "/reachable-nodes-in-subdivided-graph/",
                    "original_src": "https://leetcode.cn/problems/reachable-nodes-in-subdivided-graph/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2328.4294689238,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2203. 得到要求路径的最小带权子图",
                    "summary": "",
                    "src": "/minimum-weighted-subgraph-with-the-required-paths/",
                    "original_src": "https://leetcode.cn/problems/minimum-weighted-subgraph-with-the-required-paths/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2364.3455634374,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2577. 在网格图中访问一个格子的最少时间",
                    "summary": "",
                    "src": "/minimum-time-to-visit-a-cell-in-a-grid/",
                    "original_src": "https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2381.625583289,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "818. 赛车",
                    "summary": "",
                    "src": "/race-car/",
                    "original_src": "https://leetcode.cn/problems/race-car/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2391.8086687918,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1928. 规定时间内到达终点的最小花费",
                    "summary": "",
                    "src": "/minimum-cost-to-reach-destination-in-time/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-to-reach-destination-in-time/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2413.3969129689,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "787. K 站中转内最便宜的航班",
                    "summary": "",
                    "src": "/cheapest-flights-within-k-stops/",
                    "original_src": "https://leetcode.cn/problems/cheapest-flights-within-k-stops/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1786.4753467293,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2699. 修改图中的边权",
                    "summary": "",
                    "src": "/modify-graph-edge-weights/",
                    "original_src": "https://leetcode.cn/problems/modify-graph-edge-weights/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2873.9745576413,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1810. 隐藏网格下的最小消耗路径",
                    "summary": "",
                    "src": "/minimum-path-cost-in-a-hidden-grid/",
                    "original_src": "https://leetcode.cn/problems/minimum-path-cost-in-a-hidden-grid/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "2093. 前往目标城市的最小费用",
                    "summary": "",
                    "src": "/minimum-cost-to-reach-city-with-discounts/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-to-reach-city-with-discounts/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "2473. 购买苹果的最低成本",
                    "summary": "",
                    "src": "/minimum-cost-to-buy-apples/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-to-buy-apples/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "2737. 找到最近的标记节点",
                    "summary": "",
                    "src": "/find-the-closest-marked-node/",
                    "original_src": "https://leetcode.cn/problems/find-the-closest-marked-node/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "LCP 35. 电动车游城市",
                    "summary": "",
                    "src": "/DFPeFJ/",
                    "original_src": "https://leetcode.cn/problems/DFPeFJ/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3599. 划分数组得到最小 XOR",
                    "summary": "",
                    "src": "/partition-array-to-minimize-xor/",
                    "original_src": "https://leetcode.cn/problems/partition-array-to-minimize-xor/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1954.5247525411,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3594. 所有人渡河所需的最短时间",
                    "summary": "",
                    "src": "/minimum-time-to-transport-all-individuals/",
                    "original_src": "https://leetcode.cn/problems/minimum-time-to-transport-all-individuals/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2604.0450098035,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2714. 找到 K 次跨越的最短路径",
                    "summary": "",
                    "src": "/find-shortest-path-with-k-hops/",
                    "original_src": "https://leetcode.cn/problems/find-shortest-path-with-k-hops/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": null,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "2589. 完成所有任务的最少时间",
                    "summary": "",
                    "src": "/minimum-time-to-complete-all-tasks/",
                    "original_src": "https://leetcode.cn/problems/minimum-time-to-complete-all-tasks/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2380.5983169295,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "§3.2 全源最短路：Floyd 算法",
                    "summary": "Floyd 算法本质是三维 DP。<br><a href=\"https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/solution/dai-ni-fa-ming-floyd-suan-fa-cong-ji-yi-m8s51/\">带你发明 Floyd 算法：从记忆化搜索到递推</a><br>模板：<br>```py [sol-Python3]<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果无法从 i 到 j，则最短路长度为 math.inf",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "允许负数边权",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "节点编号从 0 到 n-1",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度",
            "summary": "def shortestPathFloyd(self, n: int, edges: List[List[int]]) -> List[List[int]]:<br>f = [[inf] * n for _ in range(n)]<br>for i in range(n):<br>f[i][i] = 0<br>for x, y, wt in edges:<br>f[x][y] = min(f[x][y], wt)  # 如果有重边，取边权最小值<br>f[y][x] = min(f[y][x], wt)  # 无向图<br>for k in range(n):<br>for i in range(n):<br>if f[i][k] == inf:  # 针对稀疏图的优化<br>continue<br>for j in range(n):<br>f[i][j] = min(f[i][j], f[i][k] + f[k][j])<br>return f<br>```<br>```java [sol-Java]<br>class Solution {<br>// 返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度<br>// 如果无法从 i 到 j，则最短路长度为 Long.MAX_VALUE / 2<br>// 允许负数边权<br>// 如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度<br>public long[][] shortestPathFloyd(int n, int[][] edges) {<br>final long INF = Long.MAX_VALUE / 2; // 防止加法溢出<br>long[][] f = new long[n][n];<br>for (int i = 0; i < n; i++) {<br>Arrays.fill(f[i], INF);<br>f[i][i] = 0;<br>}<br>for (int[] e : edges) {<br>int x = e[0];<br>int y = e[1];<br>int wt = e[2];<br>f[x][y] = Math.min(f[x][y], wt); // 如果有重边，取边权最小值<br>f[y][x] = Math.min(f[y][x], wt); // 无向图<br>}<br>for (int k = 0; k < n; k++) {<br>for (int i = 0; i < n; i++) {<br>if (f[i][k] == INF) { // 针对稀疏图的优化<br>continue;<br>}<br>for (int j = 0; j < n; j++) {<br>f[i][j] = Math.min(f[i][j], f[i][k] + f[k][j]);<br>}<br>}<br>}<br>return f;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度<br>// 如果无法从 i 到 j，则最短路长度为 LLONG_MAX / 2<br>// 允许负数边权<br>// 如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度<br>vector<vector<long long>> shortestPathFloyd(int n, vector<vector<int>>& edges) {<br>const long long INF = LLONG_MAX / 2; // 防止加法溢出<br>vector f(n, vector<long long>(n, INF));<br>for (int i = 0; i < n; i++) {<br>f[i][i] = 0;<br>}<br>for (auto& e : edges) {<br>int x = e[0], y = e[1];<br>long long wt = e[2];<br>f[x][y] = min(f[x][y], wt); // 如果有重边，取边权最小值<br>f[y][x] = min(f[y][x], wt); // 无向图<br>}<br>for (int k = 0; k < n; k++) {<br>for (int i = 0; i < n; i++) {<br>if (f[i][k] == INF) { // 针对稀疏图的优化<br>continue;<br>}<br>for (int j = 0; j < n; j++) {<br>f[i][j] = min(f[i][j], f[i][k] + f[k][j]);<br>}<br>}<br>}<br>return f;<br>}<br>```<br>```go [sol-Go]<br>// 返回一个二维列表，其中 (i,j) 这一项表示从 i 到 j 的最短路长度<br>// 如果无法从 i 到 j，则最短路长度为 math.MaxInt / 2<br>// 允许负数边权<br>// 如果计算完毕后，存在 i，使得从 i 到 i 的最短路长度小于 0，说明图中有负环<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n^3 + m)，其中 m 是 edges 的长度<br>func shortestPathFloyd(n int, edges [][]int) [][]int {<br>const inf = math.MaxInt / 2 // 防止加法溢出<br>f := make([][]int, n)<br>for i := range f {<br>f[i] = make([]int, n)<br>for j := range f[i] {<br>f[i][j] = inf<br>}<br>f[i][i] = 0<br>}<br>for _, e := range edges {<br>x, y, wt := e[0], e[1], e[2]<br>f[x][y] = min(f[x][y], wt) // 如果有重边，取边权最小值<br>f[y][x] = min(f[y][x], wt) // 无向图<br>}<br>for k := range n {<br>for i := range n {<br>if f[i][k] == inf { // 针对稀疏图的优化<br>continue<br>}<br>for j := range n {<br>f[i][j] = min(f[i][j], f[i][k]+f[k][j])<br>}<br>}<br>}<br>return f<br>}<br>```<br>**Bitset 优化 Floyd**<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "2642. 设计可以求最短路径的图类",
                    "summary": "",
                    "src": "/design-graph-with-shortest-path-calculator/",
                    "original_src": "https://leetcode.cn/problems/design-graph-with-shortest-path-calculator/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1810.6470004623,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1334. 阈值距离内邻居最少的城市",
                    "summary": "",
                    "src": "/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
                    "original_src": "https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1854.9547783559,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2976. 转换字符串的最小成本 I",
                    "summary": "",
                    "src": "/minimum-cost-to-convert-string-i/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-to-convert-string-i/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1882.0842446557,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2959. 关闭分部的可行集合数目",
                    "summary": "",
                    "src": "/number-of-possible-sets-of-closing-branches/",
                    "original_src": "https://leetcode.cn/problems/number-of-possible-sets-of-closing-branches/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2077.4738459704,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2977. 转换字符串的最小成本 II",
                    "summary": "",
                    "src": "/minimum-cost-to-convert-string-ii/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-to-convert-string-ii/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2695.809667046,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1462. 课程表 IV",
                    "summary": "",
                    "src": "/course-schedule-iv/",
                    "original_src": "https://leetcode.cn/problems/course-schedule-iv/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1692.5884631801,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "2101. 引爆最多的炸弹",
                    "summary": "",
                    "src": "/detonate-the-maximum-bombs/",
                    "original_src": "https://leetcode.cn/problems/detonate-the-maximum-bombs/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1880.0511044074,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "返回是否合并成功",
                    "summary": "涉及到 Kruskal 算法和 Prim 算法。前者一般用于稀疏图，后者一般用于稠密图。<br>> 注：如果要求最大生成树，把边权从大到小排序。<br>Kruskal 算法模板（用到了并查集，完整模板见 <a href=\"/lc-rating/list/data_structure\">数据结构题单</a>）：<br>```py [sol-Python3]<br>class UnionFind:<br>def __init__(self, n: int):<br>self._fa = list(range(n))  # 代表元<br>self.cc = n  # 连通块个数<br>def find(self, x: int) -> int:<br>if self._fa[x] != x:<br>self._fa[x] = self.find(self._fa[x])  # fa 改成代表元<br>return self._fa[x]<br>def merge(self, from_: int, to: int) -> bool:<br>x, y = self.find(from_), self.find(to)<br>if x == y:  # from 和 to 在同一个集合，不做合并<br>return False<br>self._fa[x] = y  # 合并集合。修改后就可以认为 from 和 to 在同一个集合了<br>self.cc -= 1  # 成功合并，连通块个数减一<br>return True<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "计算图的最小生成树的边权之和",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果图不连通，返回 math.inf",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "节点编号从 0 到 n-1",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度",
            "summary": "def mstKruskal(n: int, edges: List[List[int]]) -> int:<br>edges.sort(key=lambda e: e[2])<br>uf = UnionFind(n)<br>sum_wt = 0<br>for x, y, wt in edges:<br>if uf.merge(x, y):<br>sum_wt += wt<br>if uf.cc > 1:  # 图不连通<br>return inf<br>return sum_wt<br>```<br>```java [sol-Java]<br>class UnionFind {<br>private final int[] fa; // 代表元<br>public int cc; // 连通块个数<br>UnionFind(int n) {<br>// 一开始有 n 个集合 {0}, {1}, ..., {n-1}<br>// 集合 i 的代表元是自己<br>fa = new int[n];<br>for (int i = 0; i < n; i++) {<br>fa[i] = i;<br>}<br>cc = n;<br>}<br>// 返回 x 所在集合的代表元<br>// 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元<br>public int find(int x) {<br>// 如果 fa[x] == x，则表示 x 是代表元<br>if (fa[x] != x) {<br>fa[x] = find(fa[x]); // fa 改成代表元<br>}<br>return fa[x];<br>}<br>// 把 from 所在集合合并到 to 所在集合中<br>// 返回是否合并成功<br>public boolean merge(int from, int to) {<br>int x = find(from);<br>int y = find(to);<br>if (x == y) { // from 和 to 在同一个集合，不做合并<br>return false;<br>}<br>fa[x] = y; // 合并集合。修改后就可以认为 from 和 to 在同一个集合了<br>cc--; // 成功合并，连通块个数减一<br>return true;<br>}<br>}<br>class Solution {<br>// 计算图的最小生成树的边权之和<br>// 如果图不连通，返回 Long.MAX_VALUE<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度<br>public long mstKruskal(int n, int[][] edges) {<br>Arrays.sort(edges, Comparator.comparingInt(e -> e[2]));<br>UnionFind uf = new UnionFind(n);<br>long sumWt = 0;<br>for (int[] e : edges) {<br>int x = e[0], y = e[1], wt = e[2];<br>if (uf.merge(x, y)) {<br>sumWt += wt;<br>}<br>}<br>if (uf.cc > 1) { // 图不连通<br>return Long.MAX_VALUE;<br>}<br>return sumWt;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>class UnionFind {<br>vector<int> fa; // 代表元<br>public:<br>int cc; // 连通块个数<br>UnionFind(int n) : fa(n), cc(n) {<br>// 一开始有 n 个集合 {0}, {1}, ..., {n-1}<br>// 集合 i 的代表元是自己<br>ranges::iota(fa, 0);<br>}<br>// 返回 x 所在集合的代表元<br>// 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元<br>int find(int x) {<br>// 如果 fa[x] == x，则表示 x 是代表元<br>if (fa[x] != x) {<br>fa[x] = find(fa[x]); // fa 改成代表元<br>}<br>return fa[x];<br>}<br>// 把 from 所在集合合并到 to 所在集合中<br>// 返回是否合并成功<br>bool merge(int from, int to) {<br>int x = find(from), y = find(to);<br>if (x == y) { // from 和 to 在同一个集合，不做合并<br>return false;<br>}<br>fa[x] = y; // 合并集合。修改后就可以认为 from 和 to 在同一个集合了<br>cc--; // 成功合并，连通块个数减一<br>return true;<br>}<br>};<br>// 计算图的最小生成树的边权之和<br>// 如果图不连通，返回 LLONG_MAX<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度<br>long long mstKruskal(int n, vector<vector<int>>& edges) {<br>ranges::sort(edges, {}, [](const auto& e) { return e[2]; });<br>UnionFind uf(n);<br>long long sum_wt = 0;<br>for (auto& e : edges) {<br>int x = e[0], y = e[1], wt = e[2];<br>if (uf.merge(x, y)) {<br>sum_wt += wt;<br>}<br>}<br>if (uf.cc > 1) { // 图不连通<br>return LLONG_MAX;<br>}<br>return sum_wt;<br>}<br>```<br>```go [sol-Go]<br>type unionFind struct {<br>fa []int // 代表元<br>cc int   // 连通块个数<br>}<br>func newUnionFind(n int) unionFind {<br>fa := make([]int, n)<br>// 一开始有 n 个集合 {0}, {1}, ..., {n-1}<br>// 集合 i 的代表元是自己<br>for i := range fa {<br>fa[i] = i<br>}<br>return unionFind{fa, n}<br>}<br>// 返回 x 所在集合的代表元<br>// 同时做路径压缩，也就是把 x 所在集合中的所有元素的 fa 都改成代表元<br>func (u unionFind) find(x int) int {<br>// 如果 fa[x] == x，则表示 x 是代表元<br>if u.fa[x] != x {<br>u.fa[x] = u.find(u.fa[x]) // fa 改成代表元<br>}<br>return u.fa[x]<br>}<br>// 把 from 所在集合合并到 to 所在集合中<br>// 返回是否合并成功<br>func (u *unionFind) merge(from, to int) bool {<br>x, y := u.find(from), u.find(to)<br>if x == y { // from 和 to 在同一个集合，不做合并<br>return false<br>}<br>u.fa[x] = y // 合并集合。修改后就可以认为 from 和 to 在同一个集合了<br>u.cc--      // 成功合并，连通块个数减一<br>return true<br>}<br>// 计算图的最小生成树的边权之和<br>// 如果图不连通，返回 math.MaxInt<br>// 节点编号从 0 到 n-1<br>// 时间复杂度 O(n + mlogm)，其中 m 是 edges 的长度<br>func mstKruskal(n int, edges [][]int) int {<br>slices.SortFunc(edges, func(a, b []int) int { return a[2] - b[2] })<br>uf := newUnionFind(n)<br>sumWt := 0<br>for _, e := range edges {<br>x, y, wt := e[0], e[1], e[2]<br>if uf.merge(x, y) {<br>sumWt += wt<br>}<br>}<br>if uf.cc > 1 { // 图不连通<br>return math.MaxInt<br>}<br>return sumWt<br>}<br>```<br>**思维扩展**<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "1584. 连接所有点的最小费用",
                    "summary": "",
                    "src": "/min-cost-to-connect-all-points/",
                    "original_src": "https://leetcode.cn/problems/min-cost-to-connect-all-points/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1857.6431822094,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3600. 升级后最大生成树稳定性",
                    "summary": "",
                    "src": "/maximize-spanning-tree-stability-with-upgrades/",
                    "original_src": "https://leetcode.cn/problems/maximize-spanning-tree-stability-with-upgrades/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2301.0381658933,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1489. 找到最小生成树里的关键边和伪关键边",
                    "summary": "",
                    "src": "/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
                    "original_src": "https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2571.552028121,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "1135. 最低成本连通所有城市",
                    "summary": "",
                    "src": "/connecting-cities-with-minimum-cost/",
                    "original_src": "https://leetcode.cn/problems/connecting-cities-with-minimum-cost/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1752.9555725796,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "1168. 水资源分配优化",
                    "summary": "",
                    "src": "/optimize-water-distribution-in-a-village/",
                    "original_src": "https://leetcode.cn/problems/optimize-water-distribution-in-a-village/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2069.4030284676,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": true,
                    "last_update": ""
                },
                {
                    "title": "3219. 切蛋糕的最小总开销 II",
                    "summary": "",
                    "src": "/minimum-cost-for-cutting-cake-ii/",
                    "original_src": "https://leetcode.cn/problems/minimum-cost-for-cutting-cake-ii/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1789.3681547685,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "五、欧拉路径/欧拉回路",
                    "summary": "涉及到 Hierholzer 算法。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "332. 重新安排行程",
                            "summary": "",
                            "src": "/reconstruct-itinerary/",
                            "original_src": "https://leetcode.cn/problems/reconstruct-itinerary/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "753. 破解保险箱",
                            "summary": "",
                            "src": "/cracking-the-safe/",
                            "original_src": "https://leetcode.cn/problems/cracking-the-safe/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2273.7910625337,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2097. 合法重新排列数对",
                            "summary": "",
                            "src": "/valid-arrangement-of-pairs/",
                            "original_src": "https://leetcode.cn/problems/valid-arrangement-of-pairs/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2650.8996457642,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "六、强连通分量/双连通分量",
                    "summary": "涉及到 Tarjan 算法。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "1192. 查找集群内的关键连接",
                            "summary": "",
                            "src": "/critical-connections-in-a-network/",
                            "original_src": "https://leetcode.cn/problems/critical-connections-in-a-network/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2084.6866916045,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1568. 使陆地分离的最少天数",
                            "summary": "",
                            "src": "/minimum-number-of-days-to-disconnect-island/",
                            "original_src": "https://leetcode.cn/problems/minimum-number-of-days-to-disconnect-island/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2208.5532172086,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 54. 夺回据点",
                            "summary": "",
                            "src": "/s5kipK/",
                            "original_src": "https://leetcode.cn/problems/s5kipK/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3383. 施法所需最低符文数量",
                            "summary": "",
                            "src": "/minimum-runes-to-add-to-cast-spell/",
                            "original_src": "https://leetcode.cn/problems/minimum-runes-to-add-to-cast-spell/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "七、二分图染色",
                    "summary": "模板（交替染色法）：<br>```py [sol-Python3]<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "返回图的二染色",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果是二分图，返回每个节点的颜色，用 1 和 2 表示两种颜色",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "如果不是二分图，返回空列表",
            "summary": "",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [],
            "nonLeafChild": [],
            "isPremium": false,
            "last_update": ""
        },
        {
            "title": "从节点 i 开始递归，发现 i 所在连通块不是二分图",
            "summary": "def colorBipartite(n: int, edges: List[List[int]]) -> List[int]:<br>g = [[] for _ in range(n)]<br>for x, y in edges:<br>g[x].append(y)<br>g[y].append(x)<br>colors = [0] * n<br>def dfs(x: int, c: int) -> bool:<br>colors[x] = c  # 节点 x 染成颜色 c<br>for y in g[x]:<br>if colors[y] == c or \\<br>colors[y] == 0 and not dfs(y, 3 - c):  # 1 和 2 交替染色<br>return False<br>return True<br>for i, c in enumerate(colors):<br>if c == 0 and not dfs(i, 1):<br>return []<br>return colors<br>```<br>```java [sol-Java]<br>class Solution {<br>// 返回图的二染色<br>// 如果是二分图，返回每个节点的颜色，用 1 和 2 表示两种颜色<br>// 如果不是二分图，返回空列表<br>// 时间复杂度 O(n+m)，n 是点数，m 是边数<br>private int[] colorBipartite(int n, int[][] edges) {<br>// 建图（节点编号从 0 到 n-1）<br>List<Integer>[] g = new ArrayList[n];<br>Arrays.setAll(g, _ -> new ArrayList<>());<br>for (int[] e : edges) {<br>int x = e[0], y = e[1];<br>g[x].add(y);<br>g[y].add(x);<br>}<br>// colors[i] = 0 表示未访问节点 i<br>// colors[i] = 1 表示节点 i 为红色<br>// colors[i] = 2 表示节点 i 为蓝色<br>int[] colors = new int[n];<br>for (int i = 0; i < n; i++) {<br>if (colors[i] == 0 && !dfs(i, 1, g, colors)) {<br>// 从节点 i 开始递归，发现 i 所在连通块不是二分图<br>return new int[]{};<br>}<br>}<br>return colors;<br>}<br>private boolean dfs(int x, int c, List<Integer>[] g, int[] colors) {<br>colors[x] = c; // 节点 x 染成颜色 c<br>for (int y : g[x]) {<br>// 邻居 y 的颜色与 x 的相同，说明不是二分图，返回 false<br>// 或者继续递归，发现不是二分图，返回 false<br>if (colors[y] == c ||<br>colors[y] == 0 && !dfs(y, 3 - c, g, colors)) { // 1 和 2 交替染色<br>return false;<br>}<br>}<br>return true;<br>}<br>}<br>```<br>```cpp [sol-C++]<br>// 返回图的二染色<br>// 如果是二分图，返回每个节点的颜色，用 1 和 2 表示两种颜色<br>// 如果不是二分图，返回空列表<br>// 时间复杂度 O(n+m)，n 是点数，m 是边数<br>vector<int8_t> colorBipartite(int n, vector<vector<int>>& edges) {<br>// 建图（节点编号从 0 到 n-1）<br>vector<vector<int>> g(n);<br>for (auto& e : edges) {<br>int x = e[0], y = e[1];<br>g[x].push_back(y);<br>g[y].push_back(x);<br>}<br>// colors[i] = 0 表示未访问节点 i<br>// colors[i] = 1 表示节点 i 为红色<br>// colors[i] = 2 表示节点 i 为蓝色<br>vector<int8_t> colors(n);<br>// lambda 递归<br>auto dfs = [&](this auto&& dfs, int x, int8_t c) -> bool {<br>colors[x] = c; // 节点 x 染成颜色 c<br>for (int y : g[x]) {<br>// 邻居 y 的颜色与 x 的相同，说明不是二分图，返回 false<br>// 或者继续递归，发现不是二分图，返回 false<br>if (colors[y] == c ||<br>colors[y] == 0 && !dfs(y, 3 - c)) { // 1 和 2 交替染色<br>return false;<br>}<br>}<br>return true;<br>};<br>// 可能有多个连通块<br>for (int i = 0; i < n; i++) {<br>if (colors[i] == 0 && !dfs(i, 1)) {<br>// 从节点 i 开始递归，发现 i 所在连通块不是二分图<br>return {};<br>}<br>}<br>return colors;<br>}<br>```<br>```go [sol-Go]<br>// 返回图的二染色<br>// 如果是二分图，返回每个节点的颜色，用 1 和 2 表示两种颜色<br>// 如果不是二分图，返回空列表<br>// 时间复杂度 O(n+m)，n 是点数，m 是边数<br>func colorBipartite(n int, edges [][]int) []int8 {<br>// 建图（节点编号从 0 到 n-1）<br>g := make([][]int, n)<br>for _, e := range edges {<br>x, y := e[0], e[1]<br>g[x] = append(g[x], y)<br>g[y] = append(g[y], x)<br>}<br>// colors[i] = 0 表示未访问节点 i<br>// colors[i] = 1 表示节点 i 为红色<br>// colors[i] = 2 表示节点 i 为蓝色<br>colors := make([]int8, n)<br>var dfs func(int, int8) bool<br>dfs = func(x int, c int8) bool {<br>colors[x] = c // 节点 x 染成颜色 c<br>for _, y := range g[x] {<br>// 邻居 y 的颜色与 x 的相同，说明不是二分图，返回 false<br>// 或者继续递归，发现不是二分图，返回 false<br>if colors[y] == c ||<br>colors[y] == 0 && !dfs(y, 3-c) { // 1 和 2 交替染色<br>return false<br>}<br>}<br>return true<br>}<br>// 可能有多个连通块<br>for i, c := range colors {<br>if c == 0 && !dfs(i, 1) {<br>// 从节点 i 开始递归，发现 i 所在连通块不是二分图<br>return nil<br>}<br>}<br>return colors<br>}<br>```<br>关于二分图的最大匹配，见下面网络流的题目。其中标有「一对一」的题目也可以用带权二分图最大匹配做。<br>",
            "src": "",
            "original_src": "",
            "sort": 0,
            "isLeaf": false,
            "solution": "",
            "score": 0,
            "leafChild": [
                {
                    "title": "785. 判断二分图",
                    "summary": "",
                    "src": "/is-graph-bipartite/",
                    "original_src": "https://leetcode.cn/problems/is-graph-bipartite/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1624.9775945043,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "886. 可能的二分法",
                    "summary": "",
                    "src": "/possible-bipartition/",
                    "original_src": "https://leetcode.cn/problems/possible-bipartition/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 1794.5827898448,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "3710. 最大划分因子",
                    "summary": "",
                    "src": "/maximum-partition-factor/",
                    "original_src": "https://leetcode.cn/problems/maximum-partition-factor/",
                    "sort": 0,
                    "isLeaf": true,
                    "solution": null,
                    "score": 2135.1002785041,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "nonLeafChild": [
                {
                    "title": "八、网络流",
                    "summary": "由于有其他做法（比如状压 DP），难度分仅供参考。<br>**模拟费用流**<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "1947. 最大兼容性评分和",
                            "summary": "",
                            "src": "/maximum-compatibility-score-sum/",
                            "original_src": "https://leetcode.cn/problems/maximum-compatibility-score-sum/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1704.360891641,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3376. 破解锁的最少时间 I",
                            "summary": "",
                            "src": "/minimum-time-to-break-locks-i/",
                            "original_src": "https://leetcode.cn/problems/minimum-time-to-break-locks-i/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1793.2112436729,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2850. 将石头分散到网格图的最少移动次数",
                            "summary": "",
                            "src": "/minimum-moves-to-spread-stones-over-grid/",
                            "original_src": "https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2001.4515854273,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1879. 两个数组最小的异或值之和",
                            "summary": "",
                            "src": "/minimum-xor-sum-of-two-arrays/",
                            "original_src": "https://leetcode.cn/problems/minimum-xor-sum-of-two-arrays/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2145.183995267,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1349. 参加考试的最大学生数",
                            "summary": "",
                            "src": "/maximum-students-taking-exam/",
                            "original_src": "https://leetcode.cn/problems/maximum-students-taking-exam/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2385.8072128533,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2172. 数组的最大与和",
                            "summary": "",
                            "src": "/maximum-and-sum-of-array/",
                            "original_src": "https://leetcode.cn/problems/maximum-and-sum-of-array/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2392.0799451298,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3276. 选择矩阵中单元格的最大得分",
                            "summary": "",
                            "src": "/select-cells-in-grid-with-maximum-score/",
                            "original_src": "https://leetcode.cn/problems/select-cells-in-grid-with-maximum-score/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2402.6213260468,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1595. 连通两组点的最小成本",
                            "summary": "",
                            "src": "/minimum-cost-to-connect-two-groups-of-points/",
                            "original_src": "https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2537.7965575726,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3257. 放三个车的价值之和最大 II",
                            "summary": "",
                            "src": "/maximum-value-sum-by-placing-three-rooks-ii/",
                            "original_src": "https://leetcode.cn/problems/maximum-value-sum-by-placing-three-rooks-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2553.2367142614,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 04. 覆盖",
                            "summary": "",
                            "src": "/broken-board-dominoes/",
                            "original_src": "https://leetcode.cn/problems/broken-board-dominoes/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 38. 守卫城堡",
                            "summary": "",
                            "src": "/7rLGCR/",
                            "original_src": "https://leetcode.cn/problems/7rLGCR/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1820. 最多邀请的个数",
                            "summary": "",
                            "src": "/maximum-number-of-accepted-invitations/",
                            "original_src": "https://leetcode.cn/problems/maximum-number-of-accepted-invitations/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "2403. 杀死所有怪物的最短时间",
                            "summary": "",
                            "src": "/minimum-time-to-kill-all-monsters/",
                            "original_src": "https://leetcode.cn/problems/minimum-time-to-kill-all-monsters/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "3385. 破解锁的最少时间 II",
                            "summary": "",
                            "src": "/minimum-time-to-break-locks-ii/",
                            "original_src": "https://leetcode.cn/problems/minimum-time-to-break-locks-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "1066. 校园自行车分配 II",
                            "summary": "",
                            "src": "/campus-bikes-ii/",
                            "original_src": "https://leetcode.cn/problems/campus-bikes-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1885.1051527272,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "2123. 使矩阵中的 1 互不相邻的最小操作数",
                            "summary": "",
                            "src": "/minimum-operations-to-remove-adjacent-ones-in-matrix/",
                            "original_src": "https://leetcode.cn/problems/minimum-operations-to-remove-adjacent-ones-in-matrix/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "2463. 最小移动总距离",
                            "summary": "",
                            "src": "/minimum-total-distance-traveled/",
                            "original_src": "https://leetcode.cn/problems/minimum-total-distance-traveled/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2453.9054896968,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "九、其他",
                    "summary": "",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [
                        {
                            "title": "1042. 不邻接植花",
                            "summary": "",
                            "src": "/flower-planting-with-no-adjacent/",
                            "original_src": "https://leetcode.cn/problems/flower-planting-with-no-adjacent/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 1712.4010133221,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1761. 一个图中连通三元组的最小度数",
                            "summary": "",
                            "src": "/minimum-degree-of-a-connected-trio-in-a-graph/",
                            "original_src": "https://leetcode.cn/problems/minimum-degree-of-a-connected-trio-in-a-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2005.2755755378,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2508. 添加边使所有节点度数都为偶数",
                            "summary": "",
                            "src": "/add-edges-to-make-degrees-of-all-nodes-even/",
                            "original_src": "https://leetcode.cn/problems/add-edges-to-make-degrees-of-all-nodes-even/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2060.0720834082,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1579. 保证图可完全遍历",
                            "summary": "",
                            "src": "/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
                            "original_src": "https://leetcode.cn/problems/remove-max-number-of-edges-to-keep-graph-fully-traversable/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2131.7917160422,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2065. 最大化一张图中的路径价值",
                            "summary": "",
                            "src": "/maximum-path-quality-of-a-graph/",
                            "original_src": "https://leetcode.cn/problems/maximum-path-quality-of-a-graph/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2178.4249114144,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1697. 检查边长度限制的路径是否存在",
                            "summary": "",
                            "src": "/checking-existence-of-edge-length-limited-paths/",
                            "original_src": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2300.1557840589,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2242. 节点序列的最大得分",
                            "summary": "",
                            "src": "/maximum-score-of-a-node-sequence/",
                            "original_src": "https://leetcode.cn/problems/maximum-score-of-a-node-sequence/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2304.3094138939,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2493. 将节点分成尽可能多的组",
                            "summary": "",
                            "src": "/divide-nodes-into-the-maximum-number-of-groups/",
                            "original_src": "https://leetcode.cn/problems/divide-nodes-into-the-maximum-number-of-groups/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2415.2802039252,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "1782. 统计点对的数目",
                            "summary": "",
                            "src": "/count-pairs-of-nodes/",
                            "original_src": "https://leetcode.cn/problems/count-pairs-of-nodes/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2457.115574186,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3666. 使二进制字符串全为 1 的最少操作次数",
                            "summary": "",
                            "src": "/minimum-operations-to-equalize-binary-string/",
                            "original_src": "https://leetcode.cn/problems/minimum-operations-to-equalize-binary-string/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2476.6133828534,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "2612. 最少翻转操作数",
                            "summary": "",
                            "src": "/minimum-reverse-operations/",
                            "original_src": "https://leetcode.cn/problems/minimum-reverse-operations/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 2824.4551372454,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "3435. 最短公共超序列的字母出现频率",
                            "summary": "",
                            "src": "/frequencies-of-shortest-supersequences/",
                            "original_src": "https://leetcode.cn/problems/frequencies-of-shortest-supersequences/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": 3027.89612787,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "466. 统计重复个数",
                            "summary": "",
                            "src": "/count-the-repetitions/",
                            "original_src": "https://leetcode.cn/problems/count-the-repetitions/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "LCP 16. 游乐园的游览计划",
                            "summary": "",
                            "src": "/you-le-yuan-de-you-lan-ji-hua/",
                            "original_src": "https://leetcode.cn/problems/you-le-yuan-de-you-lan-ji-hua/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": false,
                            "last_update": ""
                        },
                        {
                            "title": "277. 搜寻名人",
                            "summary": "",
                            "src": "/find-the-celebrity/",
                            "original_src": "https://leetcode.cn/problems/find-the-celebrity/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "1724. 检查边长度限制的路径是否存在 II",
                            "summary": "",
                            "src": "/checking-existence-of-edge-length-limited-paths-ii/",
                            "original_src": "https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths-ii/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "2077. 殊途同归",
                            "summary": "",
                            "src": "/paths-in-maze-that-lead-to-same-room/",
                            "original_src": "https://leetcode.cn/problems/paths-in-maze-that-lead-to-same-room/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        },
                        {
                            "title": "3656. 判断是否存在简单图",
                            "summary": "",
                            "src": "/determine-if-a-simple-graph-exists/",
                            "original_src": "https://leetcode.cn/problems/determine-if-a-simple-graph-exists/",
                            "sort": 0,
                            "isLeaf": true,
                            "solution": null,
                            "score": null,
                            "leafChild": [],
                            "nonLeafChild": [],
                            "isPremium": true,
                            "last_update": ""
                        }
                    ],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "十、树上算法",
                    "summary": "见 <a href=\"/lc-rating/list/trees\">链表、树、回溯</a> 题单的第三章节。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                },
                {
                    "title": "算法题单",
                    "summary": "<a href=\"https://leetcode.cn/circle/discuss/RvFUtj/\">如何科学刷题？</a><br>1. <a href=\"/lc-rating/list/sliding_window\">滑动窗口与双指针（定长/不定长/单序列/双序列/三指针/分组循环）</a><br>2. <a href=\"/lc-rating/list/binary_search\">二分算法（二分答案/最小化最大值/最大化最小值/第K小）</a><br>3. <a href=\"/lc-rating/list/monotonic_stack\">单调栈（基础/矩形面积/贡献法/最小字典序）</a><br>4. <a href=\"/lc-rating/list/grid\">网格图（DFS/BFS/综合应用）</a><br>5. <a href=\"/lc-rating/list/bitwise_operations\">位运算（基础/性质/拆位/试填/恒等式/思维）</a><br>6. <a href=\"/lc-rating/list/graph\">图论算法（DFS/BFS/拓扑排序/基环树/最短路/最小生成树/网络流）</a><br>7. <a href=\"/lc-rating/list/dynamic_programming\">动态规划（入门/背包/划分/状态机/区间/状压/数位/数据结构优化/树形/博弈/概率期望）</a><br>8. <a href=\"/lc-rating/list/data_structure\">常用数据结构（前缀和/差分/栈/队列/堆/字典树/并查集/树状数组/线段树）</a><br>9. <a href=\"/lc-rating/list/math\">数学算法（数论/组合/概率期望/博弈/计算几何/随机算法）</a><br>10. <a href=\"/lc-rating/list/greedy\">贪心与思维（基本贪心策略/反悔/区间/字典序/数学/思维/脑筋急转弯/构造）</a><br>11. <a href=\"/lc-rating/list/trees\">链表、二叉树与回溯（前后指针/快慢指针/DFS/BFS/直径/LCA/一般树）</a><br>12. <a href=\"/lc-rating/list/string\">字符串（KMP/Z函数/Manacher/字符串哈希/AC自动机/后缀数组/子序列自动机）</a><br>如果你发现有题目可以补充进来，欢迎评论反馈。<br>",
                    "src": "",
                    "original_src": "",
                    "sort": 0,
                    "isLeaf": false,
                    "solution": "",
                    "score": 0,
                    "leafChild": [],
                    "nonLeafChild": [],
                    "isPremium": false,
                    "last_update": ""
                }
            ],
            "isPremium": false,
            "last_update": ""
        }
    ],
    "isPremium": false,
    "last_update": "2025-10-13 02:48:30"
} as ProblemCategory;